import qutip as qt
import numpy as np
from scipy.optimize import minimize

def compute_eig_diff(params):
    J_base, h = params
    num_spins = 2
    e = 0.2056  # Eccentricity Mercury
    a = 0.387098  # Semi-major axis AU
    strain = e / a
    J = J_base * (1 + strain)
    
    sz1 = qt.tensor(qt.sigmaz(), qt.qeye(2))
    sz2 = qt.tensor(qt.qeye(2), qt.sigmaz())
    sx1 = qt.tensor(qt.sigmax(), qt.qeye(2))
    sx2 = qt.tensor(qt.qeye(2), qt.sigmax())
    
    H = -J * sz1 * sz2 + h * (sx1 + sx2)
    
    eigenenergies = H.eigenenergies()
    abs_eig = np.sort(np.abs(eigenenergies))
    closest = abs_eig[np.argmin(np.abs(abs_eig - 0.0881))]
    return np.abs(closest - 0.0881)

# Initial guess
initial_params = [0.0565, 0.0075]

# Optimize
res = minimize(compute_eig_diff, initial_params, method='Nelder-Mead')
optimal_J_base, optimal_h = res.x
print("Optimal J_base:", optimal_J_base)
print("Optimal h:", optimal_h)
print("Minimal difference:", res.fun)

# Recompute and plot (optional)
strain = 0.2056 / 0.387098
J = optimal_J_base * (1 + strain)
H = -J * sz1 * sz2 + optimal_h * (sx1 + sx2)

eigenenergies = H.eigenenergies()
abs_eig = np.sort(np.abs(eigenenergies))
print("Eigenenergies absolutos ordenados:", abs_eig)

diff = np.abs(abs_eig - 0.0881)
target_idx = np.argmin(diff)
print("Mais próximo de 0.0881:", abs_eig[target_idx])
print("Diferença:", diff[target_idx])